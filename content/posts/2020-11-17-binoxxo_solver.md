---
title:  ペンシルパズル BINOXXO ソルバー
tags:	[プログラミング]
date:	2020-11-17 18:16:08 +0100
slug:   inoxxo_solver
aliases:
    - /2020/11/17/inoxxo_solver.html
---
[ペンシルパズル BINOXXO](/2020/09/01/binoxxo.html) を
[プログラムで解いて](https://github.com/isseis/blog/blob/master/assets/2020/11/binoxxo/binoxxo_solver.py) みました。

## アルゴリズム（人間用）

盤面を次のルールに従って書き換えていくと、
問題が解けます。

### 条件１：◯ならびに×が隣り合うのは2つまで

1. 空欄を挟んで同じ記号がある場合に、間の空欄を反対の記号で埋める
    * O\_O → O**X**O
2. 同じ記号が連続している場合に、その両端を反対の記号で埋める<br>
    * OO\_ → OO**X**
3. 同一行（列）に同じ記号が４つ使われている場合に、
    その記号を置くと逆の記号が３つ連続するマスを探し、
    そこに逆の記号を置く。<br>
    * （Xがすでに4つ使われていると想定して）<br>
    \_\_OX\_ → \_\_OX**O** / \_O\_X\_ → \_O\_X**O** / O\_\_X\_ → O\_\_X**O**<br>
    最後のマスにXを置くと、最初の３マスがOOOとなってしまう。
    * （Xがすでに4つ使われていると想定して）<br>
    \_\_\_\_ → **O**__**O**<br>
    最初もしくは最後のマスにXを置くと、残りの３マスがOOOとなってしまう。
3. 同一行（列）に同じ記号が３つ使われている場合に、
    ４つ目を置くと残りのマスで逆の記号が３つ並んでしまうマスを探し、
    そこに逆の記号を置く。
    * X\_\_X\_\_O\_\_X → X**OO**X\_\_O\_\_X<br>
    最初の空欄二ついずれかにXを置くと、残りのXが１つに対して残りのマスが \_\_O\_\_ となる。
    したがって \_\_O もしくは O\_\_ のいずれかが OOO となってしまう。
    * XO\_\_\_\_\_OXX → XO\_\_**O**\_\_OXX<br>
    空欄の中央に X を置くと、残りのXが一つに対して残りのマスが O\_\_X\_\_O となる。
    したがってXの左の O\_\_ もしくは右の \_\_O いずれかが OOO となる。
    * X\_\_\_\_\_\_OXX → X**O**\_\_\_\_\_OXX<br>
    最初の空欄にXを置くと、残りのXが一つに対して残りのマスが \_\_\_\_\_O となる。
    Xを残りのどこに置いてもOが３連続になる。

### 条件２：各列・行には同数の○ならびに×が入る

1. 同一行（列）に同じ記号が５つ使われている場合に、空欄を逆の記号で埋める（条件２）<br>
    * OOXOXOXXO\_ → OOXOXOXXO**X**

### 条件３：すべての行・列は異なる並びになる

1. 同一行（列）に同じ記号がすでに５つ配置されている行（列）に対して、
    その記号が同じ位置に４つ配置されている行（列）Lがある場合。
    Lの残りの１つの位置には、反対の記号を配置する（条件３）<br>
    * （他にOOXOXXOXOXという行がある場合） OOX\_\_\_OXOX → OOX**X**\_\_OXOX

## アルゴリズム（コンピューター用）

コンピューターに解かせる場合には、
条件１の３，４を細かく場合分けせず、
力づくで解かせるほうが簡単です。

まず行（列）の現在の状況が与えられると、
その行で使える残りのXとOの数が分かります。

| 行の状況            | 残り X    | 残り O |
| -                  | -:        | -: |
| X\_\_X\_\_O\_\_X    | 2         | 4 |

これで作れる組み合わせを列挙すると、
次のようになります。
人間には面倒ですが、
コンピューターなら全パターン列挙は [一瞬](https://github.com/isseis/blog/blob/0af6cc6f353cec6325fe39af6e3900d5e3454e61/assets/2020/11/binoxxo/binoxxo_solver.py#L177) です。

| 行 | 条件１を満たすか |
| - | :-: |
| XXXXOOOOOX | NG |
| XXOXXOOOOX | NG |
| XXOXOXOOOX | NG |
| XXOXOOOXOX | NG |
| XXOXOOOOXX | NG |
| XOXXXOOOOX | NG |
| XOXXOXOOOX | NG |
| XOXXOOOXOX | NG |
| XOXXOOOOXX | NG |
| XOOXXXOOOX | NG |
| XOOXXOOXOX | OK |
| XOOXXOOOXX | NG |
| XOOXOXOXOX | OK |
| XOOXOXOOXX | OK |
| XOOXOOOXXX | NG |

大半は OOO もしくは XXX と同一記号が三連続しており、
条件１を満たしません。
条件を満たすものは次の三通りです。

| 行 |
| - |
| **XOOX**XO**O**XO**X** |
| **XOOX**OX**O**XO**X** |
| **XOOX**OX**O**OX**X** |

太字は全てのパターンで共通している部分です。
もともと入力に含まれていたXとOは当然共通していますが、
それに加えて左から２文字目と３文字目もOで共通しているので、
このマス目の値が確定します。

ついでに条件２も同じアルゴリズムでカバーできます。